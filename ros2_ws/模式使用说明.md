# 模式使用说明

```cpp
enum class State {
    AutoServo,      //电机内部mit
    ManualServo,    //手动通过纯力矩控制电机
    Impdence,       //阻抗
    Admittance,     //导纳
    Gravity,        //重力补偿
    JointAutoServo, //关节自动控制,注意要初始化关节位置
    Zero ,          //设置零点
    Planning,       //以规划的轨迹到达期望点
    Gohome          //关节归零
};
```
共 9 个功能，或者说模式。

## 零 Zero
首先机械臂要校准零位。
把 “light_lift_arm_6dof_node.cpp” 中的 mode_ 赋值为 Zero
```cpp
//103行左右
mode_ = State::Zero;
control_mode.modeTransition(mode_);
```
因为不确定电机当前的角度是多少，所以有可能超过关节限制的角度，所以需要注释如下代码：
```cpp
//158行左右
 motorControl.real_time_motor_protection(motorControl.current_motor_pos, motorControl.current_motor_vel, motorControl.current_motor_tau, serial);
```
上述函数的作用是在机械臂关节超过限制的角度，速度和力矩时失能电机。注释掉之后就不会因为电机角度超限而失能电机了，但是注意《 完 成 校 零 后 要 取 消 注 释 》。

机械臂电机灯都为绿色，即表示机械臂启动成功，手动将机械臂拖到零位即可。

ctrl c退出程序。注意在退出程序前，机械臂的位置都不要变，因为校零是循环运行的。



## 一 AutoServo
使用电机内部的pid控制，控制关节位置速度力矩。


```cpp
//103行左右
mode_ = State::AutoServo;
control_mode.modeTransition(mode_);
```
把 “light_lift_arm_6dof_node.cpp”中的mode_赋值为AutoServo

如果想跟踪程序内部的轨迹（机械臂末端轨迹），把下面的代码取消注释即可

```cpp
//163行左右
llarm6dof.update_end_effector_trajectory(realtime);
```

如果想通过话题，控制末端轨迹，则需要把上述代码注释，不然程序内部的轨迹和话题订阅的轨迹会相互冲突。



## 二 ManualServo
在程序中实现电机的控制，有pid+前馈和超螺旋滑模算法。这个功能是用来测试动力学算法的。
```cpp
//103行左右
mode_ = State::ManualServo;
control_mode.modeTransition(mode_);
```
如果想跟踪程序内部的轨迹（机械臂末端轨迹），把下面的代码取消注释即可

```cpp
//163行左右
llarm6dof.update_end_effector_trajectory(realtime);
```

如果想通过话题，控制末端轨迹，则需要把上述代码注释，不然程序内部的轨迹和话题订阅的轨迹会相互冲突。

要是研究动力学算法的，可以仔细通过这个模式测试算法。


## 三 Impdence
末端阻抗，准确的说是末端刚度和阻尼控制。
```cpp
//103行左右
mode_ = State::Impdence;
control_mode.modeTransition(mode_);
```
因为减速比的原因，输出的力矩基本没有量纲。同时为了稳定和精度，我又做了很多改动。
这个模式，用来配置鼠标和键盘的控制，会比较好，因为他跟踪的效果很丝滑。
当然用话题控制时要注释掉：
```cpp
//163行左右
llarm6dof.update_end_effector_trajectory(realtime);
```

这个模式下还有一个隐藏功能： **_末端负载自适应_**


```cpp
// state_machine.cpp 中 impdence（）函数
    if(arm.cmd == "laod")
    {

        std::string link_name = "link6";

        arm.updateLinkMass(arm.kdl_chain, link_name, link_mass);

        std::cout << "某端增加： " << link_mass << " kg" << std::endl;

        arm.cmd = "nan";
    }
    else if(arm.cmd ==  "clearlaod"){

        std::string link_name = "link6";

        arm.updateLinkMass(arm.kdl_chain, link_name, 0.0);

        std::cout << "某端增加： " << 0.0 << " kg" << std::endl;

        arm.cmd = "nan";

    }
```

arm.cmd 变量就是在订阅话题的回调函数中赋值的，大家可以参考 ts_topic.cpp 中发布回调函数 void end_pos()
 


## 四 Admittance
导纳控制，在某个自由度上为力控，其他自由度为位置控制。
```cpp
//103行左右
mode_ = State::Admittance;
control_mode.modeTransition(mode_);
```
这个模式用于接触任务。
如果想跟踪程序内部的轨迹（机械臂末端轨迹），把下面的代码取消注释即可

```cpp
//163行左右
llarm6dof.update_end_effector_trajectory(realtime);
```

如果想通过话题，控制末端轨迹，则需要把上述代码注释，不然程序内部的轨迹和话题订阅的轨迹会相互冲突。

## 五 Gravity
重力补偿。
```cpp
//103行左右
mode_ = State::Gravity;
control_mode.modeTransition(mode_);
```
这个模式不会跟踪任何轨迹。

## 六 JointAutoServo
关节控制
```cpp
//103行左右
mode_ = State::JointAutoServo;
control_mode.modeTransition(mode_);
```
这个模式一般用于拖动示教，使用这个模式时一定要注释掉：
```cpp
//263行左右
if(control_mode.currentState != State::JointAutoServo)
{
  llarm6dof.comput_ik(frame);
}
```
不然ik计算的关节角度和你发送的期望关节角度会冲突。

## 七 Planning
简单的轨迹规划
```cpp
//103行左右
mode_ = State::Planning;
control_mode.modeTransition(mode_);
```
这个模式一般用于话题控制末端轨迹时使用，当你发布一个位姿（注意是点，不是轨迹）时
机械臂会规划出一个轨迹到达这个位姿。


## 话题控制说明
在介绍 Gohome 之前需要说明,
话题控制分三类:关节控制，末端控制，控制指令：
```cpp
       // 107行左右 
       //末端控制
        desir_end_pos_subscriber_ = this->create_subscription<geometry_msgs::msg::Pose>(
            "topic_control_desir_end_pos", 10, std::bind(&KDLTestNode::desir_end_pos_callback, this, std::placeholders::_1));

        //关节控制
        desir_joint_state_subscriber_ = this->create_subscription<sensor_msgs::msg::JointState>(
            "topic_control_desir_joint_state", 10, std::bind(&KDLTestNode::desir_joint_state_callback, this, std::placeholders::_1));
   
        //控制指令
         cmd_subscriber_ = this->create_subscription<std_msgs::msg::String>(
            "cmd_topic", 10, std::bind(&KDLTestNode::cmd_callback, this, std::placeholders::_1));
```
末端控制，除了Planning模式，其他的最好发布一个连续的轨迹，不然机械臂会振荡。大家可以使用鼠标控制。

关节控制，配合拖动示教使用。

控制指令，主要是切换各种模式，配合拖动示教。

对于话题控制可以在 ts_topic 节点中进行，ts_topic.cpp 中有对应的话题：

```cpp
    topic_control_desir_joint_state_publisher = this->create_publisher<sensor_msgs::msg::JointState>("topic_control_desir_joint_state", 10);

    topic_control_desir_end_pos_publisher = this->create_publisher<geometry_msgs::msg::Pose>("topic_control_desir_end_pos", 10);

    cmd_publisher = this->create_publisher<std_msgs::msg::String>("cmd_topic", 10);
```
 
```cpp
    // 定时器：每 1 秒调用一次回调函数
    timer_ = this->create_wall_timer(1ms, std::bind(&JointStatePublisher::end_pos, this));
```
  使用定时器发布话题，其中回调函数有两个：
```cpp
void joint_state()

void end_pos()
```
主要是在  end_pos() 中我们发布鼠标和键盘数据，控制机械臂。

控制逻辑大体是键盘控制位置鼠标控制姿态，具体按键对应，可以 参考代码。


## 八 Gohome
到达关节的零点。
这个模式是配合拖动示教使用的。
拖动示教需要通过话题控制和两个脚本（teach.sh, replay.sh）实现。

运行 light_lift_arm_6dof_node 节点，再运行 ts_topic 节点。


    0 确保关节都在零位，如果不在，按 p 过渡到各个关节的零位，并切换到关节控制（自动切换的）

    1 按 t 进入重力补偿

    2 ./teach.sh，然后开始拖动，ctl+c结束拖动

    3 按 p 过渡到各个关节的零位，并切换到关节控制（自动切换的）

    4 ./replay.sh 机械臂会重复拖动的动作


# 键鼠控制的键位

    空格：开启/关闭 控制

    鼠标前后：机械臂俯仰
    鼠标左右：机械臂偏航
    鼠标滚轮：机械臂翻滚

    wsad:前后左右
    qe:上下
    zc：夹爪开和


